안녕하세요! '기능 설계 에이전트'입니다.
제공해주신 요구사항(PRD)과 기존 프로젝트 분석 자료를 바탕으로, '반복 일정' 기능 개발을 위한 작업 범위 분석을 완료했습니다.

성공적인 기능 설계를 위해, 구현 방식과 정책에 대한 몇 가지 확인이 필요합니다. 아래 질문 리스트를 검토하시고 답변해주시면, 이를 바탕으로 후속 에이전트가 참고할 최종 기능 명세서를 작성하겠습니다.

---

### **반복 일정 기능 구현을 위한 질문 리스트**

#### **1. 데이터 모델 및 생성 전략**

반복 일정을 어떻게 데이터베이스에 저장하고 클라이언트에게 제공할지에 대한 근본적인 질문입니다. 이 결정은 수정 및 삭제 로직에 큰 영향을 미칩니다.

1.  **반복 일정 식별자**: 사용자가 '해당 일정만' 수정 또는 삭제하려면, 동일한 반복 규칙에서 파생된 모든 일정을 그룹으로 식별할 방법이 필요합니다. `Event` 타입에 `repeatGroupId: string`과 같은 고유 그룹 ID를 추가하는 방식을 고려하고 있는데, 이 방향이 맞을까요? 이 ID는 반복 규칙이 처음 생성될 때 부여되며, 관련된 모든 일정 인스턴스가 공유하게 됩니다.

2.  **이벤트 데이터 생성 시점**:
    *   **방안 A (백엔드 확장)**: 사용자가 반복 일정을 생성하면, 백엔드에서 `endDate`까지의 모든 개별 일정(`Event`)을 미리 생성하여 데이터베이스에 저장합니다. 클라이언트는 특정 기간의 일정을 요청하면, 백엔드는 해당 기간에 포함된 모든 개별 일정을 반환합니다.
    *   **방안 B (프론트엔드 확장)**: 데이터베이스에는 반복 규칙을 정의하는 '원본' 일정 하나만 저장합니다. 클라이언트(프론트엔드)가 캘린더를 표시할 때, 이 원본 일정과 반복 규칙(`RepeatInfo`)을 기반으로 화면에 표시할 모든 반복 일정을 동적으로 계산하여 렌더링합니다.
    *   **질문**: 현재 `useEventOperations.ts`의 `fetchEvents`는 모든 이벤트를 한 번에 가져오는 구조입니다. 반복 일정 도입 시 데이터 양이 크게 늘어날 수 있습니다. 백엔드에서 모든 인스턴스를 미리 생성하는 **방안 A**를 채택하고, API를 `GET /api/events?start=YYYY-MM-DD&end=YYYY-MM-DD`와 같이 특정 기간의 이벤트만 조회하도록 변경하는 것이 좋을까요? (방안 A를 가정하고 후속 질문을 구성했습니다.)

#### **2. 반복 일정 수정 로직**

1.  **단일 일정 수정**: 사용자가 "해당 일정만 수정"을 선택했을 때, 해당 이벤트는 "반복일정에서 분리되어 단일 일정으로 변경"된다고 명시되어 있습니다. 이를 구현하기 위해, 해당 `Event` 데이터의 `repeatGroupId`를 `null`로 변경하고 `repeat.type`을 `'none'`으로 업데이트하는 방식은 어떤가요?

2.  **전체 일정 수정**: "아니오"(전체 수정)를 선택했을 때, 수정 범위는 어떻게 되나요?
    *   **옵션 1**: 사용자가 수정한 날짜를 포함한 *과거와 미래의 모든* 관련 일정을 업데이트합니다.
    *   **옵션 2**: 사용자가 수정한 날짜를 포함한 *미래의 모든* 관련 일정만 업데이트합니다. (과거 일정은 그대로 둠)
    *   **질문**: 요구사항 상 '전체 수정'은 **옵션 1**에 가까워 보입니다. 이 방식이 맞는지 확인 부탁드립니다.

3.  **API 요청 설계**: `saveEvent` (PUT) 요청 시, 단일 수정인지 전체 수정인지 서버에 어떻게 알려줘야 할까요? 예를 들어, 요청 본문에 `updateScope: 'single' | 'all'` 과 같은 필드를 추가하는 방식을 제안합니다. 이 방식에 대해 어떻게 생각하시나요?

#### **3. 반복 일정 삭제 로직**

1.  **단일 일정 삭제**: 사용자가 "해당 일정만 삭제"를 선택했을 때의 구현 방식을 명확히 해야 합니다.
    *   **방안 A**: `repeatGroupId`를 공유하는 다른 일정은 그대로 두고, 해당 `id`를 가진 이벤트 레코드만 DB에서 물리적으로 삭제합니다. (데이터 생성 전략 1번 질문에서 '방안 A'를 택했을 때 가장 간단한 방법입니다.)
    *   **방안 B**: 원본 반복 규칙에 '예외 날짜' 정보를 추가하여, 해당 날짜의 일정은 생성되지 않도록 합니다.
    *   **질문**: **방안 A** (단순 레코드 삭제)가 요구사항을 만족시키는 가장 직관적인 방법으로 보입니다. 이 방식으로 진행해도 될까요?

2.  **API 요청 설계**: `deleteEvent` 요청 시, 전체 삭제를 어떻게 구분할 수 있을까요? 예를 들어, `DELETE /api/events/{id}?scope=all`과 같이 쿼리 파라미터를 사용해 서버에 알려주는 방식은 어떤가요? 서버는 이 요청을 받으면 `id`에 해당하는 이벤트의 `repeatGroupId`를 찾아 관련된 모든 이벤트를 삭제합니다.

#### **4. 사용자 경험 (UX) 및 UI**

1.  **수정/삭제 옵션 제공**: "해당 일정만 수정/삭제하시겠어요?" 라는 질문은 어떤 컴포넌트에서 표시할 예정인가요? 기존 `EventOperationModals.tsx`에 새로운 종류의 확인 모달(Confirm Modal)을 추가하는 형태로 구현하는 것이 적절해 보입니다.

2.  **반복 아이콘 표시 기준**: 캘린더 뷰에서 반복 일정을 아이콘으로 구분한다고 하셨습니다. `Event` 객체의 `repeat.type`이 `'none'`이 아닌 경우 아이콘을 표시하는 기준으로 삼으면 될까요?

---

위 질문들에 대한 답변을 받으면, 이 내용을 종합하여 구체적인 기능 명세서를 작성하도록 하겠습니다.