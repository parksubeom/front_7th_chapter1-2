네, '기능 설계 에이전트'로서의 임무를 시작하겠습니다. 제공해주신 사용자 요구사항(PRD)과 기존 프로젝트 분석 자료를 바탕으로, 반복 일정 기능 개발에 필요한 기술적인 부분을 명확히 하기 위한 질문 리스트를 생성하겠습니다.

---

### # 반복 일정 기능 구현을 위한 기술 질문 리스트

프로젝트 분석 결과, '반복 일정' 기능은 데이터 모델, API 통신, 날짜 처리 로직, UI 상태 관리 등 전반에 걸쳐 영향을 미칩니다. 성공적인 구현을 위해 아래 사항들에 대한 명확한 정의가 필요합니다.

#### **1. 데이터 모델 및 타입 (`types.ts`)**

새로운 필드(`seriesId`, `exceptionDates`)가 추가되고, 화면에 표시될 가상의 이벤트(`EventInstance`) 개념이 도입됩니다. 이와 관련하여 데이터 구조를 명확히 해야 합니다.

*   **Q1. `Event` 타입 변경:** 요구사항에 명시된 `seriesId`와 `exceptionDates` 필드를 `Event` 타입에 추가하는 것이 맞습니까? `seriesId`는 반복 일정의 원본(Master)을 식별하는 ID로 사용되고, `id`는 각 이벤트의 고유 ID로 유지되는 구조가 맞을까요?
    *   **제안:**
        ```typescript
        export interface Event extends EventForm {
          id: string; // 고유 ID
          seriesId?: string; // 반복 시리즈의 Master ID. 단일 일정은 null.
          exceptionDates?: string[]; // 'YYYY-MM-DD' 형식의 제외 날짜 배열
        }
        
*   **Q2. `EventInstance` 정의:** 요구사항의 '렌더링되는 이벤트 객체(`EventInstance`)'는 클라이언트 측에서 동적으로 생성되는 가상 객체입니까, 아니면 서버 API가 반환하는 새로운 타입입니까? 만약 클라이언트에서 생성한다면, `Event` 타입의 필드를 모두 가지되 `date` 필드만 반복 규칙에 따라 오버라이드되는 형태일까요?
*   **Q3. `seriesId`와 `id`의 관계:** 새로운 반복 일정을 생성할 때, 생성된 원본(Master) 이벤트의 `id` 값을 `seriesId`에 그대로 복사하여 저장하는 것이 규칙입니까? (예: `newEvent.seriesId = newEvent.id`)

#### **2. API 연동 및 데이터 관리 (`useEventOperations.ts`)**

기존 CRUD 로직은 단일 `id`를 기준으로 동작합니다. 반복 일정의 '단일/전체' 수정 및 삭제 로직은 API 호출 방식과 상태 관리를 복잡하게 만듭니다.

*   **Q4. 이벤트 조회 API (`fetchEvents`):** 기존 `/api/events` GET 요청은 모든 이벤트를 가져옵니다. 반복 기능 구현 후, 이 API는 반복 '원본(Master)' 일정 목록만 반환해야 합니까? 아니면 특정 기간(예: 현재 월) 내의 모든 반복 '인스턴스'를 계산해서 반환합니까?
    *   **시나리오 A (원본만 반환):** 클라이언트(React)가 원본 목록을 받아 `dateUtils`에서 인스턴스를 직접 생성해야 합니다. (로직 복잡도 증가)
    *   **시나리오 B (계산된 인스턴스 반환):** 서버 부하가 증가하지만 클라이언트는 받은 데이터를 그대로 렌더링하면 됩니다. (예: `GET /api/events?start=2024-05-01&end=2024-05-31`)
*   **Q5. 단일 일정 수정 (2단계 API 호출):** 요구사항에 따라 '새 일정 `POST`' 후 '원본 일정 `PUT`'을 호출합니다. 만약 두 번째 `PUT` 요청이 실패할 경우, 이미 생성된 첫 번째 `POST` 요청의 결과(새로운 단일 일정)를 롤백(삭제) 처리해야 합니까? 이에 대한 정책이 필요합니다.
*   **Q6. 단일/전체 수정 및 삭제 분기 처리:** 사용자가 반복 일정의 인스턴스를 클릭하여 수정/삭제를 시도할 때, "이 일정만" 또는 "향후 모든 일정"을 묻는 확인창(Modal)이 필요합니다. 이 확인창의 상태 관리 및 UI 로직은 어느 컴포넌트 또는 hook에서 담당해야 할까요? `useEventOperations` 훅이 `(isSeries: boolean)` 같은 파라미터를 받도록 확장하는 것이 좋을까요?

#### **3. 반복 로직 및 날짜 계산 (`dateUtils.ts`)**

캘린더 뷰에 반복 일정을 올바르게 표시하려면, 원본(Master) 이벤트를 기반으로 특정 기간 내의 모든 인스턴스를 생성하는 로직이 필요합니다.

*   **Q7. 이벤트 인스턴스 생성 함수:** `dateUtils.ts`에 새로운 함수가 필요해 보입니다. 아래와 같은 형태의 함수 시그니처를 가정하고 개발을 진행해도 되겠습니까?
    ```typescript
    // 입력: 마스터 이벤트 1개, 캘린더 뷰의 시작/종료일
    // 출력: 해당 기간 내에 생성되는 모든 이벤트 인스턴스 배열
    function expandRepeatingEvent(
      masterEvent: Event,
      viewStartDate: Date,
      viewEndDate: Date
    ): Event[] // EventInstance[] 가 더 정확할 수 있음
    ```
*   **Q8. 특수 규칙 확인:** 요구사항에 명시된 '31일 매월 반복'과 '윤년 2월 29일 매년 반복' 규칙 외에 고려해야 할 다른 날짜 예외 케이스가 있습니까? (예: 매월 마지막 주 수요일 등) 현재 명시된 두 가지 규칙만 구현하면 되는지 확인이 필요합니다.

#### **4. UI/UX 및 폼 로직 (`useEventForm.ts` 및 컴포넌트)**

사용자 경험과 직접적으로 연관된 부분으로, 명확한 가이드가 필요합니다.

*   **Q9. 반복 종료일 유효성 검사:** `repeatEndDate`를 `2025-12-31`로 제한하는 것은 하드코딩된 비즈니스 규칙입니까, 아니면 향후 변경될 수 있는 설정값입니까?
*   **Q10. 반복 아이콘 표시 기준:** 렌더링되는 이벤트 객체의 `seriesId` 필드가 `string`이고 `null`이 아닐 때 아이콘(🔄)을 표시한다고 되어있습니다. 그렇다면 반복 시리즈의 원본(Master) 이벤트 자체에도 아이콘이 표시되는 것이 맞습니까? (원본도 `seriesId` 값을 가질 것이므로)
*   **Q11. 단일 일정으로 변환된 이벤트의 ID:** 반복 일정 중 하나를 '단일 수정'하여 독립된 일정으로 만들 때, `POST /api/events`를 통해 새로 생성된 이벤트는 완전히 새로운 `id`를 부여받게 됩니다. 이 과정에서 기존 인스턴스와의 연결고리가 사라지는데, 이것이 의도된 동작이 맞는지 확인 바랍니다.

---